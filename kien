#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>



#define CLUSTER_SIZE 4
#define SECTOR_SIZE (512U)
#define MAX_FILENAME_LENGTH 8
#define MAX_EXTENSION_LENGTH 3

#pragma pack(push, 1) // exact fit - no padding
    uint16_t startClusterArray[10];
    uint16_t startClusterfolderArray[10];
typedef struct
{
    uint8_t jmp[3];
    char oem[8];
    uint16_t bytes_per_sector;//
    uint8_t sectors_per_cluster;//
    uint16_t reserved_sectors;//
    uint8_t number_of_fats;//
    uint16_t root_dir_entries;//
    uint16_t total_sectors_short; // if zero, later field is used
    uint8_t media_descriptor;
    uint16_t fat_size_sectors;//
    uint16_t sectors_per_track;
    uint16_t number_of_heads;
    uint32_t hidden_sectors;
    uint32_t total_sectors_long;

    // used by FAT12 and FAT16
    uint8_t drive_number;
    uint8_t current_head;
    uint8_t boot_signature;
    uint32_t volume_id;
    char volume_label[11];
    char fs_type[8]; // typically contains "FAT12   "
} __attribute__((packed)) Fat12BootData;
#pragma pack(pop)

typedef struct {
    uint16_t year;
    uint8_t month;
    uint8_t day;
    uint8_t hour;
    uint8_t minute;
    uint8_t second;
} Fat12DateTime;

typedef struct {
    uint8_t filename[MAX_FILENAME_LENGTH + 1]; // +1 for null terminator
    uint8_t extension[MAX_EXTENSION_LENGTH + 1]; // +1 for null terminator
    uint8_t attributes;
    Fat12DateTime creationTime;
    Fat12DateTime lastAccessTime;
    Fat12DateTime lastModifiedTime;
    uint16_t startCluster;
    uint32_t fileSize;
} Fat12Entry;

static FILE* ptr;
static Fat12BootData BootData;
Fat12Entry entry;

void readFat12Entry(uint8_t *entryData, Fat12Entry *entry);
void convertFilename(uint8_t *name, uint8_t *filename, uint8_t *extension);
void convertFat12DateTime(uint16_t time, uint16_t date, Fat12DateTime *dateTime);
void printFat12Entry(Fat12Entry *entry);
void FAT_Read_RootDir();
void FAT_READ_FOLDER(uint32_t folderStartCluster);
int address_content( int i);



//void FAT_Read_File(int fileCluster, int fileSize, FILE* fp) ;
void HAL_OpenDisk()
{
    ptr = fopen("C:\\Users\\Kien\\Downloads\\floppy.img", "rb");

    if (ptr == NULL)
    {
        printf("Error: could not open file.\n");
    }
}
//
void HAL_CloseDisk(void)
{
    fclose(ptr);
}

void HAL_Read_Sector(uint32_t index, Fat12BootData* buffer)
{
    uint32_t sector_offset = index * SECTOR_SIZE;

    fseek(ptr, sector_offset, SEEK_SET);
    fread(buffer, 1, SECTOR_SIZE, ptr);
}

void FAT_Read_RootDir()
{
	
    uint8_t buffer[SECTOR_SIZE];
    uint32_t rootDirSectorCount = ((BootData.root_dir_entries * 32) + (BootData.bytes_per_sector - 1)) / BootData.bytes_per_sector;
    uint32_t rootDirStartSector = BootData.reserved_sectors + (BootData.number_of_fats * BootData.fat_size_sectors);
    fseek(ptr, rootDirStartSector * BootData.bytes_per_sector, SEEK_SET);

    uint32_t i;
    uint32_t j;
    
    // M?ng d? luu start cluster

    uint32_t entryCount = 0;
	
    for (i = 0; i < rootDirSectorCount; i++) {
        fread(buffer, SECTOR_SIZE, 1, ptr);
        for (j = 0; j < SECTOR_SIZE; j += 32) {
            if (buffer[j] == 0x00) {
                // End of directory entries
                break;
            }
            if (buffer[j] == 0xE5) {
                // Unused entry
                continue;
            }
            if (buffer[j + 11] == 0x0F) {
                // Long filename entry
                continue;
            }
            if (buffer[j + 11] == 0x10) {
                // folder
            	
            }

            readFat12Entry(&buffer[j], &entry);
            uint8_t filename[MAX_FILENAME_LENGTH + MAX_EXTENSION_LENGTH + 2];
            convertFilename(&buffer[j], filename, entry.extension);
            printFat12Entry(&entry);
            
            // Luu start cluster vÃ o mang
            startClusterArray[entryCount] = entry.startCluster;
            entryCount++;
        }
    }
}

void readFat12Entry(uint8_t *entryData, Fat12Entry *entry)
{
    // Copy the filename and extension
    memcpy(entry->filename, entryData, MAX_FILENAME_LENGTH);
    entry->filename[MAX_FILENAME_LENGTH] = '\0';
    memcpy(entry->extension, entryData + 8, MAX_EXTENSION_LENGTH);
    entry->extension[MAX_EXTENSION_LENGTH] = '\0';

    // Copy the attributes, creation time, creation date, last access date, last modified time, last modified date, and start cluster
    entry->attributes = entryData[11];
    convertFat12DateTime(*(uint16_t *)(entryData + 16), *(uint16_t *)(entryData + 14), &entry->creationTime);
    convertFat12DateTime(*(uint16_t *)(entryData + 18), 0, &entry->lastAccessTime);
    convertFat12DateTime(*(uint16_t *)(entryData + 24), *(uint16_t *)(entryData + 22), &entry->lastModifiedTime);
    entry->startCluster = *(uint16_t *)(entryData + 26);

    // Copy the file size
    entry->fileSize = *(uint32_t *)(entryData + 28);
}

void convertFat12DateTime(uint16_t date, uint16_t time, Fat12DateTime *dateTime)
{
    // Extract the year, month, and day from the date
    dateTime->year = ((date >> 9) & 0x7f);
    dateTime->month = (date >> 5) & 0x0f;
    dateTime->day = date & 0x1f;

    // Extract the hour, minute, and second from the time
    dateTime->hour = (time >> 11) & 0x1f;
    dateTime->minute = (time >> 5) & 0x3f;
    dateTime->second = (time & 0x1f) * 2;
}

void convertFilename(uint8_t *name, uint8_t *filename, uint8_t *extension) {
    // Convert the filename to a null-terminated string
    uint32_t i;
    uint32_t j;
    for (i = 0; i < MAX_FILENAME_LENGTH && name[i] != ' '; i++) {
		filename[i] = name[i];
    }

    filename[i] = '\0';
    
    // Convert the extension to a null-terminated string
    for (j = 0; j < MAX_EXTENSION_LENGTH && extension[j] != ' '; j++) {
        extension[j] = extension[j];
    }
    extension[j] = '\0';
    
    // If the extension is not empty, append it to the filename
    if (extension[0] != '\0') {
        strcat(filename, ".");
        strcat(filename, extension);
    }
}

void printFat12Entry(Fat12Entry *entry)
{
    printf("%s.%s\t", entry->filename, entry->extension);
    printf("%c%c%c%c%c\t",
           (entry->attributes & 0x10) ? 'D' : '-',
           (entry->attributes & 0x01) ? 'R' : '-',
           (entry->attributes & 0x02) ? 'H' : '-',
           (entry->attributes & 0x04) ? 'S' : '-',
           (entry->attributes & 0x08) ? 'A' : '-');
    printf("%04d-%02d-%02d %02d:%02d:%02d\t",
           (entry->creationTime.year)+1980, entry->creationTime.month, entry->creationTime.day,
           entry->creationTime.hour, entry->creationTime.minute, entry->creationTime.second);
    printf("%04d-%02d-%02d %02d:%02d:%02d\t",
           entry->lastAccessTime.year, entry->lastAccessTime.month, entry->lastAccessTime.day,
           entry->lastAccessTime.hour, entry->lastAccessTime.minute, entry->lastAccessTime.second);
    printf("%04d-%02d-%02d %02d:%02d:%02d\t",
           (entry->lastModifiedTime.year)+1980, entry->lastModifiedTime.month, entry->lastModifiedTime.day,
           entry->lastModifiedTime.hour, entry->lastModifiedTime.minute, entry->lastModifiedTime.second);
    printf("%lu\n", entry->fileSize);
    //printf("%d", BootData.fat_size_sectors);
    printf("%x\n", entry->startCluster);
}
//******************************************** READ CONTENT FILE*******************************************************
void Fat_read_FileContent(uint32_t offset)
{
    fseek(ptr, offset, SEEK_SET);
    char* buffer = (char*)malloc(SECTOR_SIZE);
    fread(buffer, SECTOR_SIZE, 1, ptr);
    printf("%s", buffer);
    free(buffer);
}

// **********************************************************READ FOLDER***************************************************************
void FAT_Read_Folder(uint32_t folderStartSector) {
    uint8_t buffer[SECTOR_SIZE];
    //uint32_t folderStartSector = BootData.bytes_per_sector*(((folderStartCluster - 2) * BootData.sectors_per_cluster) + (BootData.reserved_sectors + (BootData.number_of_fats * BootData.fat_size_sectors))+ (BootData.root_dir_entries * 32 / BootData.bytes_per_sector));

    fseek(ptr, folderStartSector , SEEK_SET);

    uint32_t i;

    for (i = 0; i < BootData.sectors_per_cluster; i++)
	{
        fread(buffer, SECTOR_SIZE, 1, ptr);
        uint32_t j;

        for (j = 0; j < SECTOR_SIZE; j += 32)
		{
            if (buffer[j] == 0x00)
			{
                // End of directory entries
                break;
            }
            
            if (buffer[j] == 0xE5)
			{
                // Unused entry
                continue;
            }
            
            if (buffer[j] == 0x2E)
			{
                // Long filename entry
                continue;
            }
            
            if (buffer[j + 1] == 0x2E) 
            {
            	continue;
			}
            
            if (buffer[j + 11] == 0x0F)
			{
                // Long filename entry
                continue;
            }
            
            Fat12Entry entryFolder;
            readFat12Entry(&buffer[j], &entryFolder);
            uint8_t filename[MAX_FILENAME_LENGTH + MAX_EXTENSION_LENGTH + 2];
            convertFilename(&buffer[j], filename, entryFolder.extension);
            printFat12Entry(&entryFolder);
        }
    }
}
//*************************************** CALCULATOR ADDRESS CONTENT *************************************************************
int address_FileContent( int i)
{
	uint32_t data_region_start_sector = BootData.reserved_sectors + (BootData.number_of_fats * BootData.fat_size_sectors) + (BootData.root_dir_entries * 32 / BootData.bytes_per_sector);
	
	uint32_t offsetFile = (((startClusterArray[i] - 2) * BootData.sectors_per_cluster) + data_region_start_sector)*512;
	
	return offsetFile;
}



void EnterChoice()
{
	
	uint32_t localData;
	while(1)
	{
		char choice;
		printf("\nEnter Choice: ");
		fflush(stdin);
		scanf(" %c",&choice);
		fflush(stdin);
		switch (choice)
		{
			case '1':
				localData = address_FileContent(0);
				Fat_read_FileContent(localData);
				break;
			case '2':
				localData = address_FileContent(1);
				Fat_read_FileContent(localData);
				break;
			case '3':
				localData = address_FileContent(2);
				Fat_read_FileContent(localData);
				break;
			case '4':
				localData = address_FileContent(3);
				Fat_read_FileContent(localData);
				break;
			case '5':
				localData = address_FileContent(5);
				FAT_Read_Folder(localData);
				break;
		}
	}
}
void main()
{
    HAL_OpenDisk();
    HAL_Read_Sector(0, &BootData);
    FAT_Read_RootDir();
   	EnterChoice();
    HAL_CloseDisk();
}
